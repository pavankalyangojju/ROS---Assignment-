# overview
Create a Gazebo world (or reuse a TurtleBot3 world) and a 2D map file (image + YAML) that represent the environment. Put a few known points (x,y,yaw) in it (we call them waypoints: Station A/B/C/D, Docking station, Home).
Launch Gazebo with TurtleBot3, and start the standard Nav2 stack (map server, AMCL, Nav2 nav2_bringup components) so the robot has localization and planning. RViz is started for visualization.
Start a custom ROS 2 node waypoint_manager_node:
It knows the coordinates of the named waypoints (from YAML).
It publishes visualization markers in RViz for those waypoints.
It listens to commands from the GUI and sends goals to Nav2 using the NavigateToPose action.
It monitors feedback/result and handles failures/timeouts, and at the end returns robot to Home.
Start a small GUI (Tkinter):
Shows buttons for the named waypoints.
Allows selecting one or more waypoints (buttons toggle).
When user clicks “Go”, GUI publishes the chosen waypoint sequence to the waypoint manager node.
GUI displays status messages (Navigating…, Reached, Failed) by subscribing to a status topic.
Has a “Stop/Cancel” button to cancel current navigation.
All components (Gazebo, Nav2, RViz, waypoint_manager_node, GUI) are launched together via one ROS 2 launch file.

# File list
your_package/
├─ launch/
│  └─ bringup_launch.py

├─ config/
│  ├─ waypoints.yaml                   
│  ├─ nav2_params.yaml                 
│  └─ map.yaml + map.pgm 

├─ rviz/
│  └─ nav2_waypoints.rviz

├─ src/
│  ├─ waypoint_manager_node.py         
│  └─ gui_tkinter.py                   
└─ package.xml / setup.py / CMakeLists.txt

# waypoint YAML
# config/waypoints.yaml
home:   {x: 0.0,  y: 0.0,  yaw: 0.0}
station_a: {x: 1.5,  y: 0.5,  yaw: 0.0}
station_b: {x: -1.2, y: 0.8,  yaw: 1.57}
station_c: {x: -0.5, y: -1.4, yaw: -1.57}
station_d: {x: 2.2,  y: -0.7, yaw: 3.14}
docking_station: {x: 0.0, y: 2.0, yaw: 0.0}

# waypoint_manager_node.py — action client + markers + status publisher
Save as src/waypoint_manager_node.py. This node:
Loads config/waypoints.yaml
Publishes RViz visualization markers for each waypoint
Subscribes to /waypoint_sequence (std_msgs/String) where the GUI publishes names separated with commas (e.g. "station_a,station_b")
Subscribes to /cancel_nav (std_msgs/Bool) to cancel current goal
Publishes /waypoint_status (std_msgs/String) for GUI status updates

code :- https://github.com/pavankalyangojju/ROS---Assignment-/blob/main/waypoint_manager_node.py

# Simple GUI (Tkinter)
This Tkinter app:
Shows toggle buttons for all waypoint names (hardcoded to same names as YAML — or you can load the YAML similarly),
When user clicks Go, it sends the list as a comma-separated String on waypoint_sequence.
Subscribes to waypoint_status to update an on-screen label.
Stop publishes True on cancel_nav.

Code :- https://github.com/pavankalyangojju/ROS---Assignment-/blob/main/gui_tkinter.py

# Launch file
A single launch that includes:
--> Gazebo world (TurtleBot3) — you can reuse turtlebot3_gazebo launch,
--> Nav2 bringup (map server, AMCL, nav2 bringup) — include existing nav2 launch files or minimal ones,
--> Our two nodes (waypoint_manager_node and GUI),
--> RViz.
Below is a simplified example that assumes the user has installed standard TurtleBot3 + Nav2 packages. You will likely need to adapt paths to your installation and the map file. This launch includes our package nodes.

Code :- https://github.com/pavankalyangojju/ROS---Assignment-/blob/main/bringup_launch.py

# Minimal nav2_params.yaml and map.yaml
Providing full nav2 params is long; you can reuse Nav2 example params (from nav2_bringup demo) and substitute your own map path. For map.yaml (used by map_server):
image: map.pgm
resolution: 0.05
origin: [ -10.0, -10.0, 0.0 ]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
Place map.pgm in config/ (generated by gmapping/cartographer or manually).

# RViz: show waypoints and current goal
The waypoint_manager publishes waypoint_markers (MarkerArray). In RViz add a MarkerArray or Marker display subscribing to /waypoint_markers.
Also add Goal and TF and Pose displays:
--> RobotModel/TF to see robot,
--> Pose for amcl_pose,
--> Action or Goal depending on Nav2 version to see current NavigateToPose goal.
I included an rviz/nav2_waypoints.rviz placeholder; saving a small config that has Marker display for waypoint_markers helps.

# Build & run
1. Create a ROS 2 package your_package (Python-based) and place files exactly as above. In setup.py, expose scripts waypoint_manager_node and gui_tkinter as console scripts (or make them executable and install accordingly).
2. Ensure dependencies in package.xml include rclpy, std_msgs, geometry_msgs, nav2_msgs, visualization_msgs, turtlebot3_gazebo, nav2_bringup (for launch inclusion).
3. Place config/waypoints.yaml, config/map.yaml, config/map.pgm, rviz/nav2_waypoints.rviz.
4. Build the workspace:
   colcon build
   source install/setup.bash
5. Export TurtleBot3 model (if using TB3):
   export TURTLEBOT3_MODEL=burger
6. Launch:
   ros2 launch your_package bringup_launch.py
7. Use the Tkinter GUI window to choose waypoints and press **Go**.

# Behavior & failure handling
--> If a goal is rejected or the action server is unavailable, waypoint_manager publishes suitable status messages (Nav2 action server not available, Goal rejected, etc.).
--> The GUI has a Stop / Cancel button which requests cancellation. waypoint_manager forwards cancel to current goal handle and stops the sequence.
--> After finishing requested waypoints, the node always returns to home (unless cancelled).
--> If a waypoint name from GUI isn't known, manager publishes Failed: unknown waypoint X and proceeds.
# Quick testing tips
--> Test Nav2 first by manually sending a NavigateToPose goal (e.g. using ros2 action send_goal /navigate_to_pose nav2_msgs/action/NavigateToPose "{pose: {header: {frame_id: 'map'}, pose: {position: {x:1.5,y:0.5,z:0}, orientation: {z:0.0,w:1.0}}}} ), ensure robot can reach that point in Gazebo.
--> If Nav2 cannot localize, check AMCL and map transforms (tf), and ensure use_sim_time is set for Gazebo.
--> Tune the waypoints (coordinates) to reachable positions.

# Extras / improvements you can add later
--> Replace comma-separated String with a custom message or a service call for stronger typing.
--> Use an action server for higher-level "mission" control (start mission, pause, resume).
--> Save/recall custom waypoint sequences from GUI.
--> Add a live list in GUI that shows which waypoints have been visited in the current mission (subscribe to more detailed feedback).
--> Use smach or Behavior Tree for sophisticated mission logic.

# Summary
--> waypoint_manager_node reads named waypoints, publishes markers, acts as an Action client to Nav2, sequences multiple goals and returns home.
--> gui_tkinter.py is a small GUI that publishes waypoint sequences and can cancel navigation.
--> A single bringup_launch.py starts Gazebo, Nav2, RViz and both nodes so everything runs together.
--> Use config/waypoints.yaml to change or add named waypoints.
